#lang pyramid

; The (asm) language primitive executes ordinary Racket code within the codegen.rkt module, where
; the cg-* helpers are defined.

; Helpers

(defmacro (cond . cases)
  (match cases
    ['() '(%-unreachable)]
    [`((else ,x)) x]
    [`((,pred ,cons) . ,rest) `(if ,pred ,cons (cond ,@rest))]
    ))

(defmacro (%-unreachable) `(%-throw))

(defmacro (intro-var v1 . fs)
  (list* 'asm
         `(save (op 'lookup-variable-value (const (quote ,v1)) (reg 'env)))
         (map (λ (f) `(save (op ,f stack))) fs)))

(defmacro (make-arities)
  (define vs "abcdefghijklmnopqrstuvwxyz")
  (define (arity reads writes box-output? unbox-input?)
    (define uq 'unquote)
    (define qq 'quasiquote)
    (define (intro c) `(intro-var ,c ,@(maybe->list unbox-input? ''fixnum-value)))
    (define intros (reverse (for/list ([ c (in-string vs 0 reads)])
                              (intro (string->symbol (string c))))))
    (define write? (equal? writes 1))
    `(,qq (begin ,@intros
                 (asm ,(if write? `(save (,uq x)) `(perform (,uq x)))
                      ,@(maybe->list box-output? '(save (op 'make-fixnum stack)))
                      ,@(maybe->list write? `(restore 'val))))))
  `(begin            ;                    R W BO BI
     (defmacro (nullop x)            ,(arity 0 1 #t #t))
     (defmacro (nullop-unboxed x)    ,(arity 0 1 #f #f))
     (defmacro (nullproc x)          ,(arity 0 0 #f #f))
     (defmacro (unop x)              ,(arity 1 1 #t #t))
     (defmacro (unproc x)            ,(arity 1 0 #f #t))
     (defmacro (unop-unboxed-o x)    ,(arity 1 1 #f #t))
     (defmacro (unop-unboxed x)      ,(arity 1 1 #f #f))
     (defmacro (binop x)             ,(arity 2 1 #t #t))
     (defmacro (binop-unboxed-o x)   ,(arity 2 1 #f #t))
     (defmacro (binop-unboxed x)     ,(arity 2 1 #f #f))
     (defmacro (biproc x)            ,(arity 2 0 #f #t))
     (defmacro (triop x)             ,(arity 3 1 #t #t))
     (defmacro (triproc x)           ,(arity 3 0 #f #t))
     (defmacro (triproc-unboxed-o x) ,(arity 3 0 #f #t))
     (defmacro (triproc-unboxed x)   ,(arity 3 0 #f #f))
     (defmacro (stackop x)           ,(arity 0 0 #f #f))
     ))

(make-arities)

; Primitives table
(define (%-+ a b)     (binop (evm 'ADD)))
(define (%-* a b)     (binop (evm 'MUL)))
(define (%-- a b)     (binop (evm 'SUB)))
(define (%-/ a b)     (binop (evm 'DIV)))
(define (%-mod a b)   (binop (evm 'MOD)))
(define (%-= a b)     (binop-unboxed-o (evm 'EQ)))
(define (%-> a b)     (binop-unboxed-o (evm 'GT)))
(define (%-< a b)     (binop-unboxed-o (evm 'LT)))
(define (%->= a b)    (binop-unboxed-o (evm 'GE)))
(define (%-<= a b)    (binop-unboxed-o (evm 'LE)))

(define (%#-not a)     (unop-unboxed  (evm 'ISZERO)))
(define (%#-+ a b)     (binop-unboxed (evm 'ADD)))
(define (%#-* a b)     (binop-unboxed (evm 'MUL)))
(define (%#-- a b)     (binop-unboxed (evm 'SUB)))
(define (%#-u/ a b)    (binop-unboxed (evm 'DIV)))
(define (%#-u% a b)    (binop-unboxed (evm 'MOD)))
(define (%#-= a b)     (binop-unboxed (evm 'EQ)))
(define (%#-u> a b)     (binop-unboxed (evm 'GT)))
(define (%#-u< a b)     (binop-unboxed (evm 'LT)))
(define (%#-u>= a b)    (%#-not (%#-u< a b)))
(define (%#-u<= a b)    (%#-u>= b a))
(define (%#-s> a b)     (binop-unboxed (evm 'SGT)))
(define (%#-s< a b)     (binop-unboxed (evm 'SLT)))
(define (%#-s>= a b)    (%#-not (%#-s< a b)))
(define (%#-s<= a b)    (%#-s>= b a))
(define (%#-exp a b)   (binop-unboxed (evm 'EXP)))
(define (%#-and a b)   (binop-unboxed (evm 'AND)))
(define (%#-or a b)    (binop-unboxed (evm 'OR)))
(define (%#-xor a b)   (binop-unboxed (evm 'XOR)))
(define (%#-negate a)  (unop-unboxed (evm 'NOT)))
(define (%#-bitshiftl a b)
  (%#-* a (%#-exp (%-unbox 2) b)))
(define (%#-bitshiftr a b)
  (%#-u/ a (%#-exp (%-unbox 2) b)))

(define (%-suicide a) (unproc (evm 'SUICIDE)))
(define (%-address)   (nullop (evm 'ADDRESS)))
(define (%-balance a) (unop   (evm 'BALANCE)))
(define (%-log0-fixnum x)
  (asm (save (const 32)))                  ; [ 32 ]
  (intro-var x)                            ; [ x ; 32 ]
  (asm (save (op 'add (const #x20) stack)) ; [ x'; 32 ]
       (evm 'LOG0))                         ; [ ]
  )
(define (%-log1 bs t)
  (intro-var t)                            ; [ t ]
  (intro-var bs)                           ; [ bs; t ]
  (asm (evm 'DUP1)                         ; [ bs; bs; t ]
       (save (op 'add (const #x20) stack)) ; [ len; bs; t ]
       (evm 'SWAP1)                        ; [ bs; len; t ]
       (save (op 'add (const #x40) stack)) ; [ data; len; t ]
       (evm 'LOG1)                         ; [ ]
       )
  )

(define (%#-log1 ptr len t)
  (intro-var t)   ; [ t ]
  (intro-var len) ; [ len; t ]
  (intro-var ptr) ; [ ptr; len; t ]
  (asm (evm 'LOG1))
  )

(define (%#-log2 ptr len t1 t2)
  (intro-var t2)
  (intro-var t1)
  (intro-var len)
  (intro-var ptr)
  (asm (evm 'LOG2))
  )

(define (%-origin)               (nullop (evm 'ORIGIN)))
(define (%-caller)               (nullop (evm 'CALLER)))
(define (%-callvalue)            (nullop (evm 'CALLVALUE)))
(define (%-calldataload a)       (unop   (evm 'CALLDATALOAD)))
(define (%-calldatasize)         (nullop (evm 'CALLDATASIZE)))
(define (%-calldatacopy a b c)   (triop  (evm 'CALLDATACOPY)))
(define (%-timestamp)            (nullop (evm 'TIMESTAMP)))

(define (%#-tag a)            (unop-unboxed (op 'type stack)))
(define (%-store-read a)      (unop    (evm 'SLOAD)))
(define (%-store-write! a b)  (biproc  (evm 'SSTORE)))
(define (%-box a)             (unop-unboxed (op 'make-fixnum stack)))
(define (%-unbox-fixnum a)    (unop-unboxed (op 'fixnum-value stack)))
(define (%-unbox-character a) (unop-unboxed (op 'character-value stack)))
(define (%-unbox-symbol a)    (unop-unboxed (op 'symbol-value stack)))

(define (%-fixnum-lvalue x)  (%-word->pointer (%-unbox-fixnum (%-+ (%-box x) WORD))))
(define (%-word->pointer a)  (unop-unboxed (op 'word->pointer stack)))
(define (%#-mem-alloc a)      (unop-unboxed (op 'allocate stack)))

(define (%#-mem-read a b) (binop-unboxed (op 'read-memory stack stack)))
(define (%#-mem-write! a b c) (triproc-unboxed (op 'write-memory stack stack stack)))

(defmacro (%#-unbox-arguments f . xs)
  `(,f ,@(for/list ([ x xs])
           (if (exact-integer? x)
               `(%-unbox ,x)
               x))))

(defmacro (%#-mem-alloc-init a . xs)
  `((λ ()
      (define ptr (%#-mem-alloc ,a))
      ,@(for/list ([ x xs ]
                   [ n (in-naturals)])
          `(%#-mem-write! ptr (%-unbox ,n) ,x))
      ptr)))

(define (%-vector-read a b)
  (asm (save (op 'lookup-variable-value (const 'b) (reg 'env)))
       (save (op 'fixnum-value          stack))
       (save (op 'lookup-variable-value (const 'a) (reg 'env)))
       (save (op 'read-vector           stack stack))
       (restore 'val)
       ))

(define (%-vector-write! a b c)
  (asm (save (op 'lookup-variable-value (const 'c) (reg 'env)))
       (save (op 'lookup-variable-value (const 'b) (reg 'env)))
       (save (op 'fixnum-value          stack))
       (save (op 'lookup-variable-value (const 'a) (reg 'env)))
       (perform (op 'write-vector       stack stack stack))
       (save (op 'lookup-variable-value (const 'a) (reg 'env)))
       (restore 'val)
       ))

(defmacro (%#-bool->word x)
  `(begin ,x
          (asm (save (op 'bool->unboxed (reg 'val)))
               (restore 'val))
          ))

(defmacro (%#-coerce-word x)
  `(begin ,x
          (asm (save (op 'any->unboxed (reg 'val)))
               (restore 'val))
          ))

(defmacro (%-bool->fixnum a)
  `(begin
     ,a
     (asm (save (op 'bool->unboxed (reg 'val)))
          (save (op 'make-fixnum stack))
          (restore 'val))
     ))

(define (%-throw) (nullproc (evm 'REVERT)))

(define (%-call gas to value in-offset in-size out-offset out-size)
  (intro-var out-size   'fixnum-value)
  (intro-var out-offset 'fixnum-value)
  (intro-var in-size    'fixnum-value)
  (intro-var in-offset  'fixnum-value)
  (intro-var value      'fixnum-value)
  (intro-var to         'fixnum-value)
  (intro-var gas        'fixnum-value)
  (asm (evm (op 'CALL))
       (save (op 'make-fixnum stack))
       (restore 'val)))

(define %#-TAG-FIXNUM              (%-unbox-fixnum 0))
(define %#-TAG-SYMBOL              (%-unbox-fixnum 1))
(define %#-TAG-COMPILED-PROCEDURE  (%-unbox-fixnum 2))
(define %#-TAG-PRIMITIVE-PROCEDURE (%-unbox-fixnum 3))
(define %#-TAG-PAIR                (%-unbox-fixnum 4))
(define %#-TAG-VECTOR              (%-unbox-fixnum 5))
(define %#-TAG-NIL                 (%-unbox-fixnum 6))
(define %#-TAG-CONTINUATION        (%-unbox-fixnum 7))
(define %#-TAG-FRAME               (%-unbox-fixnum 8))
(define %#-TAG-ENVIRONMENT         (%-unbox-fixnum 9))
(define %#-TAG-CHARACTER           (%-unbox-fixnum 10))

(define %-MEM-ENV            #x20)
(define %-MEM-PROC           #x40)
(define %-MEM-CONTINUE       #x60)
(define %-MEM-ARGL           #x80)
(define %-MEM-VAL            #xa0)
(define %-MEM-NIL            #xc0)
(define %-MEM-ALLOCATOR      #xe0)
(define %-MEM-DYNAMIC-START #x100)

(define WORD #x20)

; Runtime support
(define (%-symbol?    x) (%#-= (%#-tag x) %#-TAG-SYMBOL))
(define (%-fixnum?    x) (%#-= (%#-tag x) %#-TAG-FIXNUM))
(define (%-character? x) (%#-= (%#-tag x) %#-TAG-CHARACTER))

(define (%-pair a b) (binop-unboxed (op 'pair stack stack)))
(define (%-left a)   (unop-unboxed (op 'left stack)))
(define (%-right a)  (unop-unboxed (op 'right stack)))
(define (%-null? a)  (unop-unboxed (op 'null? stack)))
(define (%-null)     (nullop-unboxed (op 'null)))

(defmacro (%-call-with-current-continuation f)
  `(begin (define cont (asm
                        (save (op 'save-continuation))
                        (restore 'val)))
          (,f cont)
          ))

; Common utilities
(define (%#-memcpy to from size)
  (define size-words (%#-bytes->words size))
  (define (loop n)
    (if (%#-u>= n size-words)
        to
        (begin (%#-mem-write! to n (%#-mem-read from n))
               (loop (%#-+ n (%-unbox 1))))))
  (loop (%-unbox 0)))

(define (%#-bytes->words x)
  (%#-u/ x (%-unbox WORD)))

(define (%-unbox a)
  (cond [(%-fixnum?    a) (%-unbox-fixnum    a)]
        [(%-character? a) (%-unbox-character a)]
        [(%-symbol?    a) (%-unbox-symbol    a)]
        ))

; ioctl debug helpers

(define (%#-allocate-word x)
  (intro-var x)
  (asm (save (op 'allocate (const 32)))
       (restore 'val))
  (asm (save (op 'any->unboxed stack)))
  (asm (perform (op 'write-memory (reg 'val) (const 0) stack)))
  )

(define (%#-ioctl-print-word x)
  (define ptr (%#-allocate-word x))
  (%#-log2 ptr (%-unbox 32) (%-unbox 0) (%-unbox 0))
  )

(define (%#-ioctl-print-symbol x)
  (define ptr (%#-allocate-word x))
  (%#-log2 ptr (%-unbox 32) (%-unbox 0) (%-unbox 1))
  )

; Compile-time macros

(defmacro (%-set-max-iterations! x)
  (%#-set-max-iterations! x)
  '(begin)
  )

(defmacro (%-with-lexical-named-value key value x)
  (with-lexical (unwrap-quote key) value x)
  )

(defmacro (%-lexical-value key)
  ((lexical-parameter (unwrap-quote key)))
  )
