(require "primitives.pmd")

(define serialize serialize-fixnum)

(define (serialize-fixnum data)
  (assert (fixnum? data))
  (vector-singleton (unbox data)))
  
; EVM
(define (log1 data t1)
  (let ([bs (serialize data) ])
    (%-log1 bs t1)))

(define memory-allocator
  (let ([ ptr (%-mem-alloc 3) ])
    (begin
      (%-mem-ptr-write! ptr 0   %-mem-alloc)
      (%-mem-ptr-write! ptr #20 %-mem-ptr-read)
      (%-mem-ptr-write! ptr #40 %-mem-ptr-write)
      ptr)))

(define storage-allocator
  (let ([ ptr (%-mem-alloc 3) ])
    (begin
      (%-mem-ptr-write! ptr 0   store-alloc)
      (%-mem-ptr-write! ptr #20 %-store-ptr-read)
      (%-mem-ptr-write! ptr #40 %-store-ptr-write!)
      ptr)))

(define **allocator** memory-allocator)

(define (set-allocator! a) (set! **allocator** a))

(define (with-allocator a f)
  (let ([ a **allocator** ])
    (set-allocator! x)
    (f)
    (set-allocator! a)))

(define (&alloc)     (%-mem-ptr-read **allocator** 0))
(define (&ptr-read)  (%-mem-ptr-read **allocator** #20))
(define (&ptr-write) (%-mem-ptr-read **allocator** #40))

(define (alloc sz)            ((&alloc)     sz))
(define (ptr-read ptr os)     ((&ptr-read)  ptr os))
(define (ptr-write! ptr os x) ((&ptr-write) ptr os x))

(define timestamp %-timestamp)
(define (time-since a) (- (%-timestamp) a))

; Primitives
(define null %-MEM-NIL)

(define (fixnum x)
  (let ([ ptr (alloc 2) ])
    (begin
      (ptr-write! ptr 0 %-TAG-FIXNUM)
      (ptr-write! ptr #20 x)
      ptr)))

(define (fixnum-bytes x n) (mod x (* n 8)))

(define (symbol x)
  (let ([ ptr (alloc 2) ])
    (begin
      (ptr-write! ptr 0 %-TAG-SYMBOL)
      (ptr-write! ptr #20 x))))

; (fixnum? x) implies x = (fixnum (unbox x))
; (symbol? x) implies x = (symbol (unbox x))
(define (unbox x) (ptr-read ptr #20))

(define (word x)
  (let ([ ptr (alloc 1) ])
    (begin
      (ptr-write! ptr 0 x)
      ptr)))

(define (pair a b)
  (let ([ ptr (alloc 3) ])
    (begin
      (ptr-write! ptr 0   %-TAG-NIL)
      (ptr-write! ptr #20 a)
      (ptr-write! ptr #40 b)
      ptr)))

(define (l p)    (ptr-read   ptr #20))
(define (r p)    (ptr-read   ptr #40))
(define (l! p x) (ptr-write! ptr #20 x))
(define (r! p x) (ptr-write! ptr #40 x))

(define (alloc-vector sz) (alloc (+ 3 sz)))
(define (vector-read    vec i)   (ptr-read   ptr (+ #60 i)))
(define (vector-write!  vec i x) (ptr-write! ptr (+ #60 i) x))
(define (vector-modify! vec i f) (vector-write! vec i (f (vector-read vec i))))

(define (vector xs)
  (let ([sz (length xs)]
        [vec (alloc-vector sz) ])
    (copy-list->vector! vec 0 xs)))

(define (copy-list->vector! vec i xs)
  (if (null? xs)
      (void)
      (begin
        (vector-write! vec i (l xs))
        (copy-list->vector! vec (+ i 1) (r xs)))))

(define (vector-initialize! vec i sz f)
  (if (equal? sz 0)
      (void)
      (begin
        (vector-write! vec i (f))
        (vector-modify! vec (+ i 1) f))))

(define (vector-f sz f)
  (let ([ vec (alloc-vector sz) ])
    (vector-initalize! vec 0 sz f)))

(define (vector-singleton x)
  (vector-f 1 (λ x)))

(defmacro λ lambda)

; Utility
(define + %-+)
(define - %--)
(define * %-*)
(define / %-/)
(define % %-mod)
(define = %-=)
(define > %->)
(define < %-<)
(define ptr-= %-ptr-=)

(defmacro (and  xs)
  (cond ((null? xs) 'true)
        ((null? (cdr xs)) (car xs))
        (else `(if ,(car xs)
                   (and ,(cdr xs))
                   false))))

(defmacro (or xs)
  (cond ((null? xs) 'false)
        ((null? (cdr xs)) (car xs))
        (else `(if ,(car xs)
                   true
                   (or ,(cdr xs))))))

(define (pred i) (- i 1))
(define (void) (begin))

(define (equal? a b)
  (or (ptr-= a b)
      (and (eq? (%-tag a) (%-tag b))
           (cond ((fixnum? x) (equal-fixnum? x))
                 ((symbol? x) (equal-fixnum? x))
                 (else (%-throw))))))

(define (assert x)
  (if x
      (void)
      (%-throw)))
(define (assert-equal a b) (assert (equal? a b)))
(define (assert-length xs n) (assert (>= (length xs) n)))

(define (circular f)
  (let ((this null))
    (set! this (f this))
    this))

(define (on f op) (λ (a b) (op (f a) (f b))))

(defmacro (let xs)
  (begin
    (assert-length xs 2)
    (let* ([args (first xs)]
           [body (tail xs)]
           [vars (map first args)]
           [exprs (map second args)])
      (cons `(lambda ,vars ,body) exprs))))

(defmacro (let* args)
  (begin
    (assert-length xs 2)
    (let ([args (first xs) ]
          [body (tail xs) ]
          [wrap-body (lambda (arg body)
                       `((lambda ,(l arg) ,body) ,(r arg)))]
          [wrap-args (lambda (args body)
                       (if (null? args)
                           body
                           (wrap-body (first args)
                                      (wrap-args (tail args) body))))]
          )
      (wrap-args args body))))

(define (step-size n)
  (if (= n 0)
      1
      (* 1000 (step-size (- n 1)))))

(define (error x) (%-throw))

(define wei  aeth) ; 0 
(define kwei feth) ; 1
(define Mwei peth) ; 2
(define Gwei neth) ; 3
(define Twei µeth) ; 4
(define Pwei meth) ; 5
(define Ewei eth)  ; 6
(define (aeth n) (* n (step-size 0)))
(define (feth n) (* n (step-size 1)))
(define (peth n) (* n (step-size 2)))
(define (neth n) (* n (step-size 3)))
(define (µeth n) (* n (step-size 4)))
(define (meth n) (* n (step-size 5)))
(define (eth n)  (* n (step-size 6)))
(define (keth n) (* n (step-size 7)))

(define (seconds n)    n)
(define (minutes n) (* n 60))
(define (hours n)   (* n 3600))
(define (days n)    (* n (hours 24)))
(define (weeks n)   (* n (days 7)))
(define (months n)  (* n (days 30)))
(define (years n)   (* n (days 365)))
